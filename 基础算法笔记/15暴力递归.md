# 暴力递归

递归理解动态规划的前提 

暴力递归就是尝试
1，把问题转化为规模缩小了的同类问题的子问题
2，有明确的不需要继续进行递归的条件(base case)
3，有当得到了子问题的结果之后的决策过程
4，不记录每一个子问题的解

# 题1：汉诺塔问题

打印n层汉诺塔从最左边移动到最右边的全部过程

## 解法1 ：相互依赖

创建6个子方法，分别是左->中，左->右，中->左，中->右，右->左，右->中。每个方法调用另外两个方法



## 解法2：六合一

启示，增加更多参数，可以让递归有更多功能

func(移动的数量，起始位置，目标位置，不用管的位置)

## 解法3：迭代方法

非递归方法



总结

打印次数是 2^n-1。时间复杂度是 O(2^n-1)

递归函数：不要陷入方法的具体实现，在调用的时候，把他看做黑盒，知道该写入什么参数，返回什么参数，base case是什么就够了，具体实现是现在的事情。

# 题2：打印一个字符串的全部子序列

子数列，又称子序列，在数学中，某个序列的子序列是从最初序列通过去除某些元素但不破坏余下元素的相对位置（在前或在后）而形成的新序列。

## 解法1

类似二叉树，每个字母都有选和不选两种结果，然后把每一个字母都这样做，得出结果。

接收结果的容器是List

# 题3：打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

抄一般上面的代码，然后把接收容器改成HashSet即可，会自动去重

例子，如果打印"abbb"字符串，题2就会打印很多重复的值

# 题4：打印一个字符串的全部排列

重要技巧：恢复现场，删除对象->调用迭代函数->恢复对象

全排列计算方法：n个字母，n!种

## 解法1 ：删除 恢复

差一点的递归

迭代：循环，删除一个字母，进入下一个迭代，恢复这个字母。终止条件，字母删除完了，记录结果

## 解法2：交换

迭代：循环，从index开始和index~lenth交换，迭代方法，恢复交换。终止条件lenth==0，记录结果



# 题5：打印一个字符串的全部排列，要求不要出现重复的排列

## 解1：减枝

和题3一样，如果输入的字符串是“abb”，就会出现重复
在本次迭代里，相同的字符只能交换一次（也就是自己和自己交换），其余和题4一样

## 解2：过滤

把有重复值的结果，放进set容器里去重即可。但速度比减枝慢



# 题6：逆序栈

仰望好的尝试?
给你一个栈，请你逆序这个栈,不能申请额外的数据结构,只能使用递归函数。如何实现?

两个递归实现
递归方法1返回栈的底部元素，栈其余不变。
递归方法2调用方法1，最后把得到的栈底元素压回栈



