# 动态规划-总纲

动态规划会记住重复调用的过程，当你需要重新展现某些过程的时候，可以直接调出来使用



## 讲述暴力递归和动态规划的关系

递归过程会有大量重复过程，如果记住这些重复过程，然后再调用的时候复现，这种东西就叫做动态规划





## 记忆化搜索/从顶向下的动态规划

题1解2用的技巧名。动态规划是结果不是原因

动态规划都可以由暴力递归改进过来，解决动态规划的套路



## 动态规划模型

1. 从左到右，逐个尝试
2. 范围问题：题目2
3. 样本对应模型：题目6
4. 业务限制模型：



# 题目1：

假设有排成一行的N个位置记为1~N，N一定大于或等于2
开始时机器人在其中的M位置上(M一定是1~N中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到N-1位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
给定四个参数 N、M、K、P，返回方法数

## 解1

普通迭代，遍历所有走的路线，如果到达目的地就记录

## 解2

在解1的情况下增加了’缓存‘，免去重复计算，因为参数里的变量 剩余步数和当前位置 两个变量固定时，返回值一定固定，所以用这两个值，来当key，储存唯一的返回值即可

## 解3二维动态规划

纵坐标是当前位置，横坐标是剩余步数。
第1行只能依赖左下格的数据，第5行只能依赖右上格的数据，2~4行数据是左上+左下数据之和。
（4,0）是机器人要到达的地方，（2,6）是机器人在2位置，可以移动6步

![image-20221113113639486](16暴力递归到动态规划.assets/image-20221113113639486.png)







# 题目2

给定一个整型数组arr，代表正数值不同的纸牌排成一条线
玩家A和玩家B依次拿走每张纸牌
规定玩家A先拿，玩家B后拿
但是每个玩家每次只能拿走最左或最右的纸牌
玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数

## 解1 

两个迭代方法相互调用，

## 解2

先判断有没有重复过程，有再用 缓存 优化。

## 解3

动态规划，因为是两个迭代方法相互调用，所以也需要两个二维数组参与。
找规律然后写方法实现这个规律



# 第二部分

背包问题

记忆化搜索的一个很重要的注意点

通过面试题进一步强化动态规划的解题套路：从左往右尝试
暴力枚举每一种可能，在其中找到答案



## 题目3：背包问题

给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值
给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量
返回能装下的最大价值

### 解1：暴力递归



### 解2：动态规划

1. 从解1的参数中找到，’变量‘，根据变量找到每次迭代的相同过程
2. 举具体的例子，判断是否有重复过程，如果有就可以写动态规划
3. 根据解1的返回条件，作为变量数组的起始值
4. 根据解1的递归过程，判断数组从起始值开始的演算过程
5. 数组的某一个值就是答案



## 题目4：

规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果 

### 解1

只有一个变量，那就是 下标 ，这个参数的含义是：str[0..i-1]转化无需过问，str[i.....]去转化，返回有多少种转化方法。

返回值是小标到达临界值，返回1，表示当前组合确定成功了。返回0，表示当前组合失败，不成立。

组合的可能性有两种，1是选择当前下标转化，2是选择当前和下一个字符一起转化。

### 解2

因为只有一个可变参数，所以用一维数组即可。

把解1的代码做替换即可



## 题目5：

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文
arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来
返回需要至少多少张贴纸可以完成这个任务
例子：str= "babac"，arr = {"ba","c","abcd"}
ba + ba + c  3  。abcd + abcd 2 。 abcd+ba 2
所以返回2

### 解1递归



### 解2 递归优化

减枝。重复项是贴纸的出现次序，如题目的例子，ba + ba + c会出现几次，分别是ba + ba + c，ba + c + ba，c + ba + ba等，出现的顺序不一样但是内容都一样，所以这个要剪掉。

那么先减去str里先出现的字母，比如str= "babac"的b，因为"c"无法减去头字母所以跳过，依次类推，答案是不会变的，因为我们只是把 ba + ba + c，ba + c + ba，c + ba + ba，删除只出现ba + ba + c而已，答案是一样的。

难点在于如何快速遍历贴纸字符串里，是否有str头字母，可以把字符串数组转化成整数二维数组int [ stickers.length ] [26]，目的是快速查找符合要求的字母。

其余都类似解1

### 解3动态规划

字符串在递归的时候，会被贴纸删除几个字符串形成新的字符串，而这个新字符串会重复出现所以可以动态规划 ，但很难找到固定长度的结构来储存答案，那直接用容器就好了

字符串不同于数字，数字大部分可以用固定长度的数组解决，而类似字符串这种，	临界找不到或者很多，直接用容器傻缓存就好了



## 题目6：最长公共子序列长度

给定两个字符串str1和str2，
返回这两个字符串的最长公共子序列长度
比如 ： str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”
最长公共子序列是“123456”，所以返回长度6

### 解1



### 解2

根据方法里的递归函数，判断当前数依赖哪里，再把最初的依赖值初始化。

把解1 里的迭代方法，替换成数组的某个坐标
